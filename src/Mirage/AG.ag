optpragmas
{
{-# LANGUAGE OverloadedStrings #-}
}

{
import           Data.Text                      ( Text )
import           Data.Map                       ( Map )
import qualified Data.Map                      as Map
import           Graphics.Rendering.Cairo.Internal
                                                ( Render(..), Cairo )
import           Data.Foldable                  ( traverse_ )

import           Mirage.Shape
import           Mirage.Cairo

import           System.IO.Unsafe               ( unsafePerformIO )
import           Control.Monad.Trans.Reader

data AttrLoc = AttrLocLeft | AttrLocRight deriving Eq

data NodeRole = NodeRoleParent | NodeRoleChild deriving Eq

askCairo :: Render Cairo
askCairo = Render ask

textExtents :: Cairo -> FontOptions -> Text -> TextExtents
textExtents cairo font txt = unsafePerformIO $
  runReaderT (runRender (mirageTextExtents font txt)) cairo
}

data Rule
    | Rule parent      :: Node
           children    :: Nodes
           locals      :: Locals
           connections :: Connections

type Nodes = [Node]
type Locals = [Text]
type Connections = [Connection]

data Connection | Connection source :: Address target    :: Address
{
data Address = Address
  { addressNode :: Text
  , addressAttr :: Maybe Text
  } deriving (Eq, Ord)
}

data Node
    | Node name :: Text
           inhs :: Attributes
           syns :: Attributes 

type Attributes = [Text]


attr Nodes Locals Attributes Rule Node
    inh nodeFont :: FontOptions
    inh nodeFontExtents :: FontExtents

    inh attrFont :: FontOptions
    inh attrFontExtents :: FontExtents
    
    inh cairo :: {Cairo}

attr Rule Connections Connection
    inh bb :: {(Double, Double)}

attr Nodes Locals Attributes Node
    -- bounding box size
    syn bb :: {(Double, Double)}
    
    -- position (bottom left corner of bounding box)
    inh pos :: {(Double, Double)}

    -- used for drawing the lines between the nodes
    syn sources use {<>} {mempty} :: {Map Address (Double, Double)}
    syn targets use {<>} {mempty} :: {Map Address (Double, Double)}

attr Nodes Locals Connections Attributes Connection Rule Node
    syn shapes use {<>} {mempty} :: {[Shape]}

attr Attributes
    inh location :: AttrLoc
    inh fieldName :: Text
    syn n use {+} {0} :: Int

attr Attributes Node Nodes
    inh role :: {NodeRole}

attr Connections Connection
    inh sources :: {Map Address (Double, Double)}
    inh targets :: {Map Address (Double, Double)}

sem Attributes
  | Nil  lhs.bb = (0, 0)
  | Cons
      +n = (+ 1)
      loc.hgt = fontExtentsHeight @lhs.attrFontExtents
      (TextExtents loc.w) = textExtents @lhs.cairo @lhs.attrFont @hd
      lhs.bb = (@loc.bb_w, @loc.bb_h)
      loc.(bb_w, bb_h) = {
        let (x, y) = @tl.bb
        in ( max x (@loc.w + 1.5 * @loc.hgt + @loc.nd * @loc.hgt)
           , y + @loc.hgt
           )
      }
      tl.pos = {
        let (x, y) = @lhs.pos
        in ( x + if @lhs.location == AttrLocLeft
                   then 0
                   else @loc.bb_w - fst @tl.bb
           , y - if @lhs.role == NodeRoleParent then @loc.hgt else 0
           )
      }
      loc.nd = fromIntegral @tl.n
      loc.x = {
        fst @lhs.pos
          + let x = @loc.hgt / 2 + @loc.hgt * @loc.nd
            in if @lhs.location == AttrLocLeft then x else @loc.bb_w - x
      }
      loc.y = {
        snd @lhs.pos
          - if @lhs.role == NodeRoleParent
              then @loc.hgt / 2
              else @loc.hgt / 2 + snd @tl.bb
      }
      loc.isSource = (@lhs.location == AttrLocLeft) == (@lhs.role == NodeRoleParent)
      loc.addPort = Map.insert (Address @lhs.fieldName (Just @hd)) (@loc.x, @loc.y)
      +sources = if @loc.isSource then @loc.addPort else id
      +targets = if @loc.isSource then id else @loc.addPort
      +shapes = {
        ([ Disk (if @loc.isSource then (1, 2 / 5, 0) else (0, 2 / 3, 3 / 4))
                (@loc.x, @loc.y) 
                (0.45 * @loc.hgt)
         , Text ( @loc.x + if @lhs.location == AttrLocLeft
                             then @loc.hgt / 2
                             else - @loc.hgt / 2
                , @loc.y
                )
                (if @lhs.location == AttrLocLeft
                   then HorizontalAlignLeft
                   else HorizontalAlignRight)
                VerticalAlignCenter
                @lhs.attrFont
                @hd
         ] <>)
      }

sem Node
  | Node 
      loc.ahgt = fontExtentsHeight @lhs.attrFontExtents
      loc.nhgt = fontExtentsHeight @lhs.nodeFontExtents
      (TextExtents loc.w) = textExtents @lhs.cairo @lhs.nodeFont @name
      lhs.bb = (@loc.bb_w, @loc.bb_h)
      (loc.bb_w, loc.bb_h) = {
        let (xi, yi) = @inhs.bb
            (xs, ys) = @syns.bb
        in ( max @loc.w (fromIntegral (abs (@inhs.n - @syns.n)) * @loc.ahgt + max @loc.ahgt (xi + xs) + @loc.ahgt)
           , @loc.nhgt + max yi ys + if @loc.hasSource then @loc.ahgt else 0
           )
      }
      loc.hasSource = @lhs.role == NodeRoleChild
      inhs.pos = {
        let (x, y) = @lhs.pos
        in ( x + @ahgt * fromIntegral (max 0 (@syns.n - @inhs.n))
           , y - if @lhs.role == NodeRoleParent
                   then 0
                   else @loc.nhgt + fromIntegral (max 0 (@syns.n - @inhs.n)) * @loc.ahgt
           )
      }
      syns.pos = {
        let (x, y) = @lhs.pos
        in ( x + @loc.bb_w - fst @syns.bb - @loc.ahgt * fromIntegral (max 0 (@inhs.n - @syns.n))
           , y - if @lhs.role == NodeRoleParent
               then 0
               else @loc.nhgt + fromIntegral (max 0 (@inhs.n - @syns.n)) * @loc.ahgt
           )
      }
      loc.fieldName = @name
      (inhs.location, syns.location) = (AttrLocLeft, AttrLocRight)
      loc.portPos = (fst @lhs.pos + @loc.bb_w / 2, snd @lhs.pos - @loc.bb_h + @loc.ahgt / 2)
      +sources = if @loc.hasSource then Map.insert (Address (if @lhs.role == NodeRoleParent then "lhs" else @name) Nothing) @loc.portPos else id
      +shapes = {
        let (x, y) = @lhs.pos
        in (([ PolyLine
               (x, y - if @lhs.role == NodeRoleParent then @loc.bb_h else 0)
               (let anh = fromIntegral (max @inhs.n @syns.n) * @loc.ahgt + if @loc.hasSource then @loc.ahgt / 2 else 0
                    nnh = @loc.nhgt
                    c = if @lhs.role == NodeRoleParent then 1 else -1
                in [ (0                  , c * nnh)
                   , (anh                , c * anh)
                   , (@loc.bb_w - 2 * anh, 0)
                   , (anh                , -c * anh)
                   , (0                  , -c * nnh)
                   , (- @loc.bb_w        , 0)
                   ]
               )
             , Text
               ( x + @loc.bb_w / 2
               , y - if @lhs.role == NodeRoleParent
                       then @loc.bb_h - @loc.nhgt
                       else 0
               )
               HorizontalAlignCenter
               VerticalAlignBottom
               @lhs.nodeFont
               @name
             ]
             ++ if @loc.hasSource
                  then [Disk (1, 2 / 5, 0) @loc.portPos (0.45 * @loc.ahgt)]
                  else []
            ) <>)
      }

sem Nodes
  | Nil lhs.bb = (0, 0)
  | Cons
      hd.pos = @lhs.pos
      tl.pos = let (x, y) = @lhs.pos in (x + 20 + fst @hd.bb, y)
      lhs.bb = {
        let (x , y ) = @hd.bb 
            (xs, ys) = @tl.bb
        in (x + 20 + xs, max y ys)
      }

sem Locals
  | Nil lhs.bb = (0, 0)
  | Cons
      loc.nhgt = fontExtentsHeight @lhs.nodeFontExtents
      loc.ahgt = fontExtentsHeight @lhs.attrFontExtents
      (TextExtents loc.w) = textExtents @lhs.cairo @lhs.nodeFont @hd
      loc.bb_w = @loc.w + @loc.ahgt
      loc.bb_h = 2 * @loc.ahgt + @loc.nhgt
      tl.pos = let (x, y) = @lhs.pos in (x + @loc.bb_w + 20, y)
      loc.sourcePos = let (x, y) = @lhs.pos in (x + @loc.bb_w / 2, y - @loc.bb_h + @loc.ahgt)
      loc.targetPos = let (x, y) = @lhs.pos in (x + @loc.bb_w / 2, y)
      +sources = Map.insert (Address "loc" (Just @hd)) @loc.sourcePos
      +targets = Map.insert (Address "loc" (Just @hd)) @loc.targetPos
      +shapes = {
        let (x, y) = @lhs.pos
        in ([ PolyLine (x + @loc.ahgt / 2,y)
                       [ (@loc.w         , 0)
                       , (@loc.ahgt / 2  , - @loc.ahgt / 2)
                       , (0              , - @loc.nhgt)
                       , (- @loc.ahgt / 2, - @loc.ahgt / 2)
                       , (- @loc.w       , 0)
                       , (- @loc.ahgt / 2, @loc.ahgt / 2)
                       , (0              , @loc.nhgt)
                       , (@loc.ahgt / 2  , @loc.ahgt / 2)
                       ]
            , Disk (1, 2 / 5, 0)
                   @loc.sourcePos
                   (0.45 * @loc.ahgt)
            , Disk (0, 2 / 3, 3 / 4)
                   @loc.targetPos
                   (0.45 * @loc.ahgt)
            , Text (x + @loc.ahgt / 2, y - @loc.ahgt / 2)
                   HorizontalAlignLeft
                   VerticalAlignBottom
                   @lhs.nodeFont
                   @hd
            ] <>)
      }

sem Rule
  | Rule
      (loc.w, loc.h) = @lhs.bb
      parent.pos = {
        let (pw, ph) = @parent.bb
        in (@loc.w / 2 - pw / 2, 0.2 * @loc.h + ph / 2)
      }
      parent.role = NodeRoleParent
      children.pos = {
        let (cw, ch) = @children.bb
        in (@loc.w / 2 - cw / 2, 0.8 * @loc.h + ch / 2)
      }
      children.role = NodeRoleChild
      locals.pos = {
        let (lw, lh) = @locals.bb
            (pw, ph) = @parent.bb
        in (@loc.w / 2 + pw / 2 + 20 - lw / 2, @loc.h / 2 + lh / 2)
      }
      connections.bb = @lhs.bb
      connections.sources = @locals.sources <> @children.sources <> @parent.sources
      connections.targets = @locals.targets <> @children.targets <> @parent.targets
      lhs.shapes = @connections.shapes <> @locals.shapes <> @children.shapes <> @parent.shapes

sem Connection
  | Connection
      +shapes = {
        case (,) <$> Map.lookup @source @lhs.sources <*> Map.lookup @target @lhs.targets of
          Nothing -> id
          Just ((x,y),(x',y')) -> 
            ([ Bezier
               (x, y)
               ( x
               , if addressNode @source == "lhs"
                 then y + 0.2 * snd @lhs.bb
                 else y - 0.2 * snd @lhs.bb
               )
               ( x'
               , if addressNode @target `elem` ["lhs", "loc"]
                 then y' + 0.2 * snd @lhs.bb
                 else y' - 0.2 * snd @lhs.bb
               )
               (x', y')
             ] <>)
      }

{
ruleShapes
  :: Cairo
  -> FontOptions
  -> FontExtents
  -> FontOptions
  -> FontExtents
  -> (Double, Double)
  -> Rule
  -> [Shape]
ruleShapes cairo nodeFont nodeFontExtents attrFont attrFontExtents bb rule =
  shapes_Syn_Rule $ wrap_Rule (sem_Rule rule) Inh_Rule
    { cairo_Inh_Rule = cairo
    , nodeFont_Inh_Rule = nodeFont
    , nodeFontExtents_Inh_Rule = nodeFontExtents
    , attrFont_Inh_Rule = attrFont
    , attrFontExtents_Inh_Rule = attrFontExtents
    , bb_Inh_Rule = bb
    }

}
